# Сравнение клиентского и веб-модуля

В подключаемых модулях FormIt используются два разных модуля JavaScript.

* Панель, на которой отображается HTML (веб-модуль).
* Клиентский модуль (FormIt) отправляет вызовы в FormIt и его ядро геометрии.

Два этих модуля JavaScript работают в разных процессах.

## **Сравнение клиентского модуля (FormIt) с веб-модулем (HTML)**

FormIt одновременно запускает несколько модулей JavaScript.

* В приложении FormIt имеется собственный модуль JavaScript.
* Каждая панель инструментов для подключаемого модуля содержит собственный модуль JavaScript.
* Каждая панель подключаемого модуля имеет собственный модуль JavaScript (Chromium).

Подключаемые модули позволяют указывать место загрузки JavaScript.

![](../../../.gitbook/assets/d14.png)

### Клиентский модуль (FormIt)

Указывается с помощью [manifest.json](https://github.com/FormIt3D/FormItExamplePlugins/blob/master/HelloBlockAsync/v23\_0/manifest.json#L8)

```
    "Scripts": [
        "PLUGINLOCATION/blockFormItSide.js",
        "https://formit3d.github.io/FormItExamplePlugins/SharedPluginFiles/PluginUtils18_0.js"
    ]
```

### Веб-модуль (HTML)

Указывается с помощью [index.html](https://github.com/FormIt3D/FormItExamplePlugins/blob/master/HelloBlockAsync/v23\_0/index.html#L7)

* Сценарии для веб-модуля загружаются с веб-страницы.
* Сценарии для веб-модуля могут вызывать JavaScript клиентского модуля (FormIt) путем нескольких асинхронных вызовов.

## Ниже приведены три метода вызова команд клиентского модуля (FormIt) из подключаемого веб-модуля.

### Метод 1\. FormItInterface.CallMethod

`CallMethod` получает имя функции и аргументы, которые будут выполняться в модуле FormIt. Переданная функция будет вызвана, результатом чего будет вызов функции.

```
    var args = {
        "w": 10,
        "l": 10,
        "h": 10
    }
    FormItInterface.CallMethod("CreateBlock", args, function(result)
    {
        // Result of the function call
    });
```

**Достоинства**

➕  `await` не требуется.

**Недостатки**

➖ Чтобы получить результат, требуется обратный вызов. Он называется «кто знает, когда».

➖ Определение сценариев выполняется в двух разных местах.

➖ Логика подключаемого модуля должна быть разделена на два разных файла.

### **Метод 2\. FormIt.CallJS**

***Доступно только в FormIt 2022.1 или более поздней версии**

CallJS использует функцию JavaScript, вызываемую на стороне FormIt, и объект arguments.json.

```
var args =
{
    "w": 10,
    "l": 10,
    "h": 10
};
var result = await FormIt.CallJS("CreateBlock", args);
```

**Достоинства**

➕ Результат доступен, когда он необходим.

**Недостатки**

➖ **** Необходимо специально выделять все асинхронные вызовы с помощью операторов ожидания (await). Если о них забыть, возникают серьезные проблемы.

➖ **** Может потребоваться больше времени из-за `await`.

### **Метод 3 (асинхронный/ожидание)**

```
const pt1 = await WSM.Geom.Point3d(0,0,0);
```

При асинхронном вызове веб-модуль вызывает модуль FormIt. Этот вызов начинается в одном процессе и передается в другой процесс, а затем результат передается назад в начальный процесс. Вот почему требуется оператор ожидания (await).

По умолчанию можно вызывать только встроенные API-интерфейсы FormIt.

**Достоинства**

➕ Результат доступен, когда он необходим.

➕ Позволяет объединить весь код в один файл JS, запускаемый из веб-модуля. В файле manifest.json сценарии не определены.

**Недостатки**

➖ **** Необходимо специально выделять все асинхронные вызовы с помощью `await`. Если о них забыть, возникают серьезные проблемы.

➖ **** Может потребоваться больше времени из-за `await.`.

### Метод 4 (RegisterAsyncAPI)

***Доступно только в FormIt 2023.0 или более поздней версии**

Чтобы вызвать пользовательскую функцию на стороне FormIt, ее необходимо зарегистрировать. Например:

**Клиентский модуль (FormIt)**

```
FormIt.RegisterAsyncAPI("HelloBlockAsync", "CreateBlock", "l, w, h");
// CreateBlock runs from FormIt.
HelloBlockAsync.CreateBlock = function(args)
{
    return { "Result" : "It Worked!!"};
}
```

**Веб-модуль (HTML)**

```
var result = await HelloBlockAsync.CreateBlock(l, w, h);
```

См. пример в разделе [HelloBlockAsync](https://github.com/FormIt3D/FormItExamplePlugins/tree/master/HelloBlockAsync/v23\_0).

**Достоинства**

➕ Результат доступен, когда он необходим.

➕ Позволяет объединить весь код в один файл JS, запускаемый из веб-модуля. В файле manifest.json сценарии не определены.

**Недостатки**

➖ **** Необходимо специально выделять все асинхронные вызовы с помощью операторов ожидания (await). Если о них забыть, возникают серьезные проблемы.

➖ **** Может потребоваться больше времени из-за `await.`.

##
