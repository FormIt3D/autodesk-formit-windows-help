# Сравнение клиентских и веб-модулей

В подключаемых модулях FormIt используются два разных модуля JavaScript.&#x20;

* Панель, на которой отображается HTML (веб-модуль).
* Клиентский модуль (FormIt) отправляет вызовы в FormIt и его ядро геометрии.&#x20;

Два этих модуля JavaScript работают в разных процессах.

## **Сравнение клиентских (FormIt) и веб-модулей (HTML)**

FormIt одновременно запускает несколько модулей JavaScript.

* В приложении FormIt имеется собственный модуль JavaScript.
* Каждая панель инструментов для подключаемого модуля содержит собственный модуль JavaScript.
* Каждая панель подключаемого модуля имеет собственный модуль JavaScript (Chromium).

Подключаемые модули позволяют указывать место загрузки JavaScript.

![](../../../.gitbook/assets/d14.png)

### Клиентский модуль (FormIt)

Указывается с помощью файла [manifest.json](https://github.com/FormIt3D/FormItExamplePlugins/blob/master/HelloBlockAsync/v23\_0/manifest.json#L8)

```
    "Scripts": [
        "PLUGINLOCATION/blockFormItSide.js",
        "https://formit3d.github.io/FormItExamplePlugins/SharedPluginFiles/PluginUtils18_0.js"
    ]

```

### Веб-модуль (HTML)

Указывается с помощью файла [index.html](https://github.com/FormIt3D/FormItExamplePlugins/blob/master/HelloBlockAsync/v23\_0/index.html#L7)

* Сценарии для веб-модуля загружаются с веб-страницы.
* Сценарии для веб-модуля могут вызывать JavaScript клиентского модуля (FormIt) путем нескольких асинхронных вызовов.

## Ниже приведены три метода вызова команд клиентского модуля (FormIt) из подключаемого веб-модуля.

### Метод 1. FormItInterface.CallMethod

`CallMethod` получает имя функции и аргументы, которые будут выполняться в модуле FormIt. Переданная функция будет вызвана, результатом чего будет вызов функции.

```
    var args = {
        "w": 10,
        "l": 10,
        "h": 10
    }
    FormItInterface.CallMethod("CreateBlock", args, function(result)
    {
        // Result of the function call
    });
```

**Преимущества**&#x20;

➕  `await` не требуется.&#x20;

**Недостатки**&#x20;

➖ Чтобы получить результат, требуется обратный вызов. Он называется «кто знает, когда».&#x20;

➖ Определение сценариев выполняется в двух разных местах.&#x20;

➖ Логика подключаемого модуля должна быть разделена на два разных файла.

### **Метод 2. FormIt.CallJS**&#x20

**\*Доступно только в FormIt 2022.1 и более поздних версиях**

CallJS использует функцию JavaScript, вызываемую на стороне FormIt, и объект arguments.json.

```
var args =
{
    "w": 10,
    "l": 10,
    "h": 10
};
var result = await FormIt.CallJS("CreateBlock", args);

```

**Преимущества**&#x20;

➕ Результат доступен, когда он необходим.

**Недостатки**&#x20;

➖ **** Необходимо специально выделять все асинхронные вызовы с помощью операторов ожидания. Если о них забыть, возникают серьезные проблемы.

➖ **** Может потребоваться больше времени из-за `await`.

### **Метод 3 (асинхронный/ожидание)**

```
const pt1 = await WSM.Geom.Point3d(0,0,0);
```

При асинхронном вызове веб-модуль вызывает модуль FormIt. Этот вызов начинается в одном процессе и передается в другой процесс, а затем результат передается назад в начальный процесс. Вот почему требуется оператор ожидания.&#x20;

По умолчанию можно вызывать только встроенные API-интерфейсы FormIt.

**Преимущества**&#x20;

➕ Результат доступен, когда он необходим.&#x20;

➕ Позволяет объединить весь код в один файл JS, запускаемый из веб-модуля. В файле manifest.json сценарии не определяются.

**Недостатки**&#x20;

➖ **** Необходимо специально выделять все асинхронные вызовы с помощью `await`. Если о них забыть, возникают серьезные проблемы.&#x20;

➖ **** Может потребоваться больше времени из-за `await.`.

### Метод 4 (RegisterAsyncAPI)&#x20;

**\*Доступно только в FormIt 2023.0 и более поздних версиях**&#x20;

Чтобы вызвать пользовательскую функцию на стороне FormIt, эту функцию необходимо зарегистрировать. Пример&#x20;

**Клиентский модуль (FormIt)**

```
FormIt.RegisterAsyncAPI("HelloBlockAsync", "CreateBlock", "l, w, h");
// CreateBlock runs from FormIt.
HelloBlockAsync.CreateBlock = function(args)
{
    return { "Result" : "It Worked!!"};
}
```

**Веб-модуль (HTML)**

```
var result = await HelloBlockAsync.CreateBlock(l, w, h);
```

См. пример в разделе [HelloBlockAsync](https://github.com/FormIt3D/FormItExamplePlugins/tree/master/HelloBlockAsync/v23\_0).

**Преимущества**&#x20;

➕ Результат доступен, когда он необходим.&#x20;

➕ Позволяет объединить весь код в один файл JS, запускаемый из веб-модуля. В файле manifest.json сценарии не определяются.

**Недостатки**&#x20;

➖ **** Необходимо специально выделять все асинхронные вызовы с помощью операторов ожидания. Если о них забыть, возникают серьезные проблемы.&#x20;

➖ **** Может потребоваться больше времени из-за `await.`.

##
